#!/bin/bash

BW_SESSION=
AUTO_LOCK=900 # 15 minutes, default for bitwarden apps
NOTIFICATION_LENGTH=1 # number of seconds to display notifications
ITEMS= # Holds the available items in memory
LOADING_PID= # Stores the pid of the loading indicator
ICON_CACHE_DIR="$HOME/.cache/bwmenu/icons" # icon cache dir
VAULT_CACHE="$HOME/.cache/bwmenu/vault.gpg" # item cache dir
BW_LOGIN_INFO="./.bwlogin" # file containing clientid and clientsecret for login

# Keyboard shortcuts
: ${KB_SYNC="Alt+r"}
: ${KB_LOCK="Alt+L"}
: ${KB_COPY_FIELD="Alt+c"}
: ${KB_ROW_UP="Alt+k,Up"}
: ${KB_ROW_DOWN="Alt+j,Down"}
: ${KB_MOVE_CHAR_BACK="Alt+h,Left"}
: ${KB_MOVE_CHAR_FORWARD="Alt+l,Right"}

# Item type classification. only TYPE_LOGIN is used
TYPE_LOGIN=1
TYPE_NOTE=2
TYPE_CARD=3
TYPE_IDENTITY=4

# exit with a notification ($2) and code ($1)
exit_notification() {
    (rofi -e "$2" & export pid=$! && sleep $NOTIFICATION_LENGTH && kill $pid)
    exit "$1"
}

# show loading screen with message ($1)
show_loading() {
    rofi -e "$1" & LOADING_PID=$!
}

# kill loading screen
unshow_loading() {
    kill "$LOADING_PID"
    LOADING_PID=-1
}

# authenticate
login() {
    show_loading "Logging in..."
    if [[ ! -f $BW_LOGIN_INFO ]]; then # Check if BW_LOGIN_INFO exists
        exit_notification 1 "Error: Auth file not found at $BW_LOGIN_INFO"
    fi
    # Read the login info file
    clientid=$(sed -n '1p' "$BW_LOGIN_INFO")
    clientsecret=$(sed -n '2p' "$BW_LOGIN_INFO")
    if [[ -z $clientid || -z $clientsecret ]]; then # verify vars are set
        exit_notification 1 "Error: Client ID and/or Client Secret is missing in $BW_LOGIN_INFO"
    fi
    ret=$(BW_CLIENTID=$clientid BW_CLIENTSECRET=$clientsecret bw login --apikey 2>&1)
    if [[ $? -ne 0 ]]; then # if login fails
        exit_notification 1 "Error: Failed to login: $ret"
    fi
    unshow_loading
}

# get session key. prompt for password if necessary
# if $1 is set, it will be used as the password
get_session_key() {
    # if bw_session has not been set or has expired
    if ! key=$(keyctl request user bw_session 2>/dev/null); then
        rm -f "$VAULT_CACHE"
        if [[ -n $1 ]]; then # if $1 is set, it is the master password.
            mpw=$1
        else # otherwise, prompt for password
            mpw=$(rofi -dmenu -p "Master Password" -password -l 0) || exit $?
        fi
        show_loading "Unlocking Vault..."
        if ! ret="$(bw --raw --nointeraction unlock "$mpw" 2>&1)"; then
            unshow_loading
            # if it fails because user is not logged in, login and retry
            if echo "$ret" | grep -q "not logged in"; then
                login
                get_session_key $mpw
                return
            fi
            exit_notification 1 "Error: Could not unlock vault: $ret"
        fi
        export BW_SESSION=$ret
        unshow_loading
        key=$(echo "$BW_SESSION" | keyctl padd user bw_session @u)
    else # otherwise, grab the BW_SESSION from keyctl using the key
        BW_SESSION=$(keyctl pipe "$key")
    fi
    keyctl timeout "$key" $AUTO_LOCK # set timeout for vault lock for vault lock
}

# Load encrypted passwords from cache if exists
load_cache() {
    if [ -f "$VAULT_CACHE" ]; then
        show_loading "Loading Password Cache..."
        ITEMS=$(gpg --quiet -d --batch --passphrase "$BW_SESSION" --cipher-algo AES256 "$VAULT_CACHE")
        unshow_loading
    else
        load_items
    fi
}

# Pre-fetch all the items
load_items() {
    show_loading "Caching Passwords..."
    if ! ret=$(bw --nointeraction list items --session "$BW_SESSION" 2>&1); then
        unshow_loading
        lock_vault
        # if it fails because user is not logged in, login and retry
        if echo "$ret" | grep -q "not logged in"; then
            get_session_key
            load_items
            return
        fi
        exit_notification $? "Error: Could not load items: $ret"
    fi
    ITEMS=$ret
    mkdir -p "$(dirname "$VAULT_CACHE")"
    echo "$ITEMS" | gpg -c --batch --passphrase "$BW_SESSION" --cipher-algo AES256 -o "$VAULT_CACHE"
    unshow_loading
}

# display main rofi menu
show_items() {
    show_loading "Loading items and caching images..."
    # Get the list of item names and their URIs
    items_with_data=$(echo "$ITEMS" | jq -r '[.[] | select(has("login")) | "\(.name)\t\(.login.uris[0].uri // empty)"] | .[]')

    rofi_input=""
    while IFS=$'\t' read -r item_name uri; do
        # Escape ampersands and other special characters
        escaped_item_name=$(echo "$item_name" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')
        icon_path=$(get_favicon "$uri")
        rofi_input+="<span size=\"small\">$escaped_item_name</span>\0icon\x1f$icon_path\n"
    done <<< "$items_with_data"

    # pass to rofi_menu
    unshow_loading
    if item=$(echo -e -n "$rofi_input" | rofi_main_menu); then
        item=$(echo -n "$item" | sed 's/<[^>]*>//g' | jq -Rs )
        item_array=$(echo "$ITEMS" | (jq -r "map(select((.name == $item) and (.type == $TYPE_LOGIN)))"))
        submenu "$item_array"
    else
        case "$?" in
            10) sync_vault;;
            11) lock_vault
                exit_notification 0 "Success: Vault Locked";;
            *) exit "0";;
        esac
    fi
}

# display item submenu. $1 is submenu menu items
submenu() {
    # Check for multiple values and handle error
    if [ "$(echo "$1" | jq 'length')" -ne 1 ]; then
        exit_notification 1 "Error: Item $(echo "$1" | jq '.[0].name') is duplicated. Cannot display."
    fi

    item=$(echo "$1" | jq '.[0]')
    fields=()

    # Collect standard fields
    [[ -n "$(echo "$item" | jq -r '.login.username // empty')" ]] && fields+=("username: $(echo "$item" | jq -r '.login.username')")
    [[ -n "$(echo "$item" | jq -r '.login.password // empty')" ]] && fields+=("password: ********")
    [[ -n "$(echo "$item" | jq -r '.login.totp // empty')" ]] && fields+=("totp")
    uris=$(echo "$item" | jq -r '.login.uris[].uri // empty')
    [[ -n "$uris" ]] && while read -r uri; do fields+=("url: $uri"); done <<< "$uris"

    # Collect custom fields
    custom_fields=$(echo "$item" | jq -r '.fields[]? | "\(.name): \(.value // empty)"')
    [[ -n "$custom_fields" ]] && while read -r custom_field; do fields+=("$custom_field"); done <<< "$custom_fields"

    # Display the menu and handle selection
    field_selection=$(printf '%s\n' "${fields[@]}" | rofi_submenu)
    rofi_exit_code=$?
    if [[ -n "$field_selection" ]]; then
        field_name=$(echo "$field_selection" | cut -d: -f1)
        value=$(echo "$field_selection" | cut -d':' -f2- | sed 's/^ //')

        case "$field_name" in
            password)
                value=$(echo "$item" | jq -r '.login.password') ;;  # Reveal password if selected
            totp)
                show_loading "Fetching TOTP..."
                id=$(echo "$1" | jq -r ".[0].id")
                if ! totp=$(bw --session "$BW_SESSION" get totp "$id" 2>&1); then
                    unshow_loading
                    exit_notification 1 "Error: failed to get TOTP: $totp"
                fi
                value=$totp
                unshow_loading
            ;;
        esac

        if [[ $rofi_exit_code -eq 10 ]]; then
            echo -n "$value" | xclip -selection clipboard -r
            exit_notification 0 "Success: Copied to clipboard"
        else
            xdotool type --clearmodifiers "$value"
        fi
    fi
}

# main rofi menu
rofi_main_menu() {
    msg="| <b>$KB_SYNC</b>: sync | <b>$KB_LOCK</b>: lock |"
    rofi -dmenu -p 'Search' \
        -i -no-custom \
        -kb-row-up "$KB_ROW_UP" \
        -kb-row-down "$KB_ROW_DOWN" \
        -kb-move-char-back "$KB_MOVE_CHAR_BACK" \
        -kb-move-char-forward "$KB_MOVE_CHAR_FORWARD" \
        -markup-rows \
        -mesg "$msg" \
        -kb-custom-1 $KB_SYNC \
        -kb-custom-2 $KB_LOCK
}

# Function to display the submenu with appropriate keybindings
rofi_submenu() {
    msg="| <b>Enter</b>: Type Val | <b>$KB_COPY_FIELD</b>: Copy Val |"
    rofi -dmenu -p 'Field' \
        -i -no-custom \
        -kb-row-up "$KB_ROW_UP" \
        -kb-row-down "$KB_ROW_DOWN" \
        -kb-move-char-back "$KB_MOVE_CHAR_BACK" \
        -kb-move-char-forward "$KB_MOVE_CHAR_FORWARD" \
        -kb-custom-1 "$KB_COPY_FIELD" \
        -mesg "$msg"
}

# icon cache management
get_favicon() {
    local uri="$1"
    local domain
    domain=$(echo "$uri" | awk -F/ '{print $3}' | sed 's/^www\.//')

    local icon_path="$ICON_CACHE_DIR/$domain.ico"

    if [ -f "$icon_path" ]; then # if icon is cached, return it
        echo "$icon_path"
    else # otherwise, cache and return it
        mkdir -p "$ICON_CACHE_DIR"
        local favicon_url="https://icons.duckduckgo.com/ip3/$domain.ico"
        wget -qO "$icon_path" "$favicon_url" || cp "./password-icon.png" "$icon_path"
        echo $icon_path
    fi
}

sync_vault() {
    show_loading "Syncing password store... $1"
    if ! error="$(bw --nointeraction sync --session "$BW_SESSION" 2>&1)"; then
        unshow_loading
        # if it fails because user is not logged in, lock vault and retry
        if echo "$error" | grep -q "not logged in"; then
            lock_vault
            get_session_key
            sync_vault
            return
        fi
        exit_notification 1 "Error: Failed to sync bitwarden: $error"
    fi
    rm -f "$VAULT_CACHE"
    load_items
    unshow_loading
    show_items
}

# lock vault by removing session from keyctl and locking the cli
lock_vault() {
    show_loading "Locking vault..."
    keyctl purge user bw_session &>/dev/null
    bw lock &>/dev/null
    unshow_loading
}

get_session_key
load_cache
show_items
