#!/usr/bin/env bash

BW_HASH=
AUTO_LOCK=900 # 15 minutes, default for bitwarden apps
NOTIFICATION_LENGTH=1 # number of seconds to display notifications
ITEMS= # Holds the available items in memory
LOADING_PID= # Stores the pid of the loading indicator
CACHE_FILE=/tmp/bwmenu/logins.gpg # item cache dir
ICON_CACHE_DIR="$HOME/.cache/rofi-bitwarden-icons" # icon cache dir

# Keyboard shortcuts
: ${KB_SYNC="Alt+r"}
: ${KB_LOCK="Alt+L"}
: ${KB_COPY_FIELD="Alt+c"}
: ${KB_ROW_UP="Alt+k,Up"}
: ${KB_ROW_DOWN="Alt+j,Down"}
: ${KB_MOVE_CHAR_BACK="Alt+h,Left"}
: ${KB_MOVE_CHAR_FORWARD="Alt+l,Right"}

# Item type classification
TYPE_LOGIN=1
TYPE_NOTE=2
TYPE_CARD=3
TYPE_IDENTITY=4

# Extract item or items matching .name
# $1: item name
array_from_name() {
    item_name=$(echo -n "$1" | jq -Rs)
    echo "$ITEMS" | jq -r "map(select((.name == $item_name) and (.type == $TYPE_LOGIN)))"
}

ask_password() {
    rm -f "$CACHE_FILE"
    mpw=$(printf '' | rofi -dmenu -p "Master Password" -password -l 0) || exit $?
    show_loading "Unlocking Vault..."
    if ! out="$(bw --raw --nointeraction unlock "$mpw" 2>&1)"; then
        unshow_loading
        exit_notification 1 "Error: Could not unlock vault: $out"
    fi
    unshow_loading
    echo "$out"
}

get_session_key() {
    if ! key_id=$(keyctl request user bw_session 2>/dev/null); then
        session=$(ask_password) || exit $?
        echo $key_id
        key_id=$(echo "$session" | keyctl padd user bw_session @u)
    fi
    keyctl timeout "$key_id" $AUTO_LOCK
    BW_HASH=$(keyctl pipe "$key_id")
}

# Load encrypted passwords from cache if exists
load_cache() {
    if [ -f "$CACHE_FILE" ]; then
        ITEMS=$(gpg --quiet -d --batch --passphrase "$BW_HASH" --cipher-algo AES256 "$CACHE_FILE")
    else
        load_items
    fi
}

# Pre-fetch all the items
load_items() {
    if ! ITEMS=$(bw --nointeraction list items --session "$BW_HASH" 2>/dev/null); then
        keyctl purge user bw_session &>/dev/null
        exit_notification $? "Error: Could not load items: $ITEMS"
    fi
    mkdir -p "$(dirname "$CACHE_FILE")"
    echo "$ITEMS" | gpg -c --batch --passphrase "$BW_HASH" --cipher-algo AES256 -o "$CACHE_FILE"
}

exit_notification() {
    local code="$1"
    local message="$2"
    (rofi -e "$message" & export ROFI_PID=$! && sleep $NOTIFICATION_LENGTH && kill $ROFI_PID)
    exit "$code"
}

show_loading() {
    rofi -e "$1" & LOADING_PID=$!
}

unshow_loading() {
    kill "$LOADING_PID"
    LOADING_PID=-1
}

# Show the Rofi menu with options
# Reads items from stdin
rofi_menu() {
    actions=(
        -kb-custom-1 $KB_SYNC # exit code 10
        -kb-custom-2 $KB_LOCK # exit code 11
    )

msg="| <b>$KB_SYNC</b>: sync | <b>$KB_LOCK</b>: lock |"

rofi -dmenu -p 'Search' \
    -i -no-custom \
    -kb-row-up "$KB_ROW_UP" \
    -kb-row-down "$KB_ROW_DOWN" \
    -kb-move-char-back "$KB_MOVE_CHAR_BACK" \
    -kb-move-char-forward "$KB_MOVE_CHAR_FORWARD" \
    -markup-rows \
    -mesg "$msg" \
    "${actions[@]}"
}

show_items() {
    show_loading "Managing cache..."

    # Get the list of item names and their URIs
    items_with_data=$(echo "$ITEMS" | jq -r '[.[] | select(has("login")) | "\(.name)\t\(.login.uris[0].uri // empty)"] | .[]')

    rofi_input=""
    while IFS=$'\t' read -r item_name uri; do
        # Escape ampersands and other special characters
        escaped_item_name=$(echo "$item_name" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')
        icon_path=$(get_favicon "$uri")
        rofi_input+="<span size=\"small\">$escaped_item_name</span>\0icon\x1f$icon_path\n"
    done <<< "$items_with_data"

    # Now, pass to rofi_menu
    unshow_loading
    if item=$(echo -e -n "$rofi_input" | rofi_menu); then
        # Remove markup tags from the selected item
        item=$(echo "$item" | sed 's/<[^>]*>//g')
        item_array="$(array_from_name "$item")"
        show_entry_fields "$item_array"
    else
        rofi_exit_code=$?
        echo $rofi_exit_code
        on_rofi_exit "$rofi_exit_code"
    fi
}

get_favicon() {
    local uri="$1"
    local domain
    domain=$(echo "$uri" | awk -F/ '{print $3}' | sed 's/^www\.//')

    local icon_path="$ICON_CACHE_DIR/$domain.ico"

    # If icon is cached, return it immediately
    if [ -f "$icon_path" ]; then
        echo "$icon_path"
        return
    fi

    # Return a default icon immediately while fetching the favicon asynchronously
    echo "/usr/share/icons/hicolor/64x64/apps/bitwarden.png" &

    # Fetch the favicon asynchronously
    (
        mkdir -p "$ICON_CACHE_DIR"
        local favicon_url="https://icons.duckduckgo.com/ip3/$domain.ico"
        wget -qO "$icon_path" "$favicon_url" || cp "/usr/share/icons/hicolor/64x64/apps/bitwarden.png" "$icon_path"
    ) &
}

# Re-sync the BitWarden items with the server
sync_bitwarden() {
    show_loading "Syncing password store..."
    if ! error="$(bw --nointeraction sync --session "$BW_HASH" 2>/dev/null)"; then
        unshow_loading
        exit_notification 1 "Error: Failed to sync bitwarden: $error"
    fi
    rm -f "$CACHE_FILE"
    load_items
    unshow_loading
    show_items
}

# Evaluate the rofi exit codes
on_rofi_exit() {
    case "$1" in
        10) sync_bitwarden;;
        11) lock_vault;;
        *) exit "$1";;
    esac
}

# Get the TOTP
# $1: item array
get_totp() {
    show_loading "Fetching TOTP..."
    id=$(echo "$1" | jq -r ".[0].id")
    if ! totp=$(bw --session "$BW_HASH" get totp "$id" 2>&1); then
        unshow_loading
        exit_notification 1 "Error: failed to get TOTP: $totp"
    fi
    echo -n "$totp"
    unshow_loading
}

# Lock the vault by purging the key used to store the session hash
lock_vault() {
    keyctl purge user bw_session &>/dev/null
    exit_notification 0 "Success: Vault Locked"
}

# # New function to display the submenu with available fields
# show_entry_fields() {
#     # Check for multiple values and error
#     if [ "$(echo "$1" | jq 'length')" -ne 1 ]; then
#         exit_notification 1 "Error: Item $(echo "$1" | jq '.[0].name') is duplicated. Cannot display."
#     fi

#     item=$(echo "$1" | jq '.[0]')
#     fields=()
#     username=$(echo "$item" | jq -r '.login.username // empty')
#     if [ -n "$username" ]; then
#         fields+=("username: $username")
#     fi
#     password=$(echo "$item" | jq -r '.login.password // empty')
#     if [ -n "$password" ]; then
#         fields+=("password: ********")
#     fi
#     totp=$(echo "$item" | jq -r '.login.totp // empty')
#     if [ -n "$totp" ]; then
#         fields+=("totp")
#     fi
#     uris=$(echo "$item" | jq -r '.login.uris[].uri // empty')
#     if [ -n "$uris" ]; then
#         while read -r uri; do
#             fields+=("url: $uri")
#         done <<< "$uris"
#     fi
#     if field_selection=$(printf '%s\n' "${fields[@]}" | rofi_field_menu); then
#         field_name=$(echo "$field_selection" | cut -d: -f1)
#         value=""
#         case "$field_name" in
#             username)
#                 value="$username"
#                 ;;
#             password)
#                 value="$password"
#                 ;;
#             totp)
#                 value="$(get_totp "$1")"
#                 ;;
#             url)
#                 value=$(echo "$field_selection" | cut -d' ' -f2-)
#                 ;;
#         esac
#         xdotool type --clearmodifiers $value
#     else
#         rofi_exit_code=$?
#         on_rofi_field_exit "$rofi_exit_code" "$1" "$field_selection"
#     fi
# }
# New function to display the submenu with available fields

# show_entry_fields() {
#     # Check for multiple values and error
#     if [ "$(echo "$1" | jq 'length')" -ne 1 ]; then
#         exit_notification 1 "Error: Item $(echo "$1" | jq '.[0].name') is duplicated. Cannot display."
#     fi

#     item=$(echo "$1" | jq '.[0]')
#     fields=()

#     # Standard fields
#     username=$(echo "$item" | jq -r '.login.username // empty')
#     if [ -n "$username" ]; then
#         fields+=("username: $username")
#     fi
#     password=$(echo "$item" | jq -r '.login.password // empty')
#     if [ -n "$password" ]; then
#         fields+=("password: ********")
#     fi
#     totp=$(echo "$item" | jq -r '.login.totp // empty')
#     if [ -n "$totp" ]; then
#         fields+=("totp")
#     fi
#     uris=$(echo "$item" | jq -r '.login.uris[].uri // empty')
#     if [ -n "$uris" ]; then
#         while read -r uri; do
#             fields+=("url: $uri")
#         done <<< "$uris"
#     fi
#     # Custom fields
#     custom_fields=$(echo "$item" | jq -r '.fields[]? | "\(.name): \(.value // empty)"')
#     if [ -n "$custom_fields" ]; then
#         while read -r custom_field; do
#             fields+=("$custom_field")
#         done <<< "$custom_fields"
#     fi
#     # Display and handle field selection
#     if field_selection=$(printf '%s\n' "${fields[@]}" | rofi_field_menu); then
#         field_name=$(echo "$field_selection" | cut -d: -f1)
#         value=""
#         case "$field_name" in
#             username)
#                 value="$username"
#                 ;;
#             password)
#                 value="$password"
#                 ;;
#             totp)
#                 value="$(get_totp "$1")"
#                 ;;
#             url)
#                 value=$(echo "$field_selection" | cut -d' ' -f2-)
#                 ;;
#             *) # custom fields
#                 value=$(echo "$field_selection" | cut -d':' -f2- | sed 's/^ //')
#                 ;;
#         esac
#         xdotool type --clearmodifiers "$value"
#     else
#         rofi_exit_code=$?
#         on_rofi_field_exit "$rofi_exit_code" "$1" "$field_selection"
#     fi
# }

# # Handle exit codes from the field submenu
# on_rofi_field_exit() {
#     local exit_code="$1"
#     local item_array="$2"
#     local field_selection="$3"

#     case "$exit_code" in
#         10) # Copy to clipboard
#             field_name=$(echo "$field_selection" | cut -d: -f1)
#             value=""
#             item=$(echo "$item_array" | jq '.[0]')
#             case "$field_name" in
#                 username)
#                     value=$(echo "$item" | jq -r '.login.username')
#                     ;;
#                 password)
#                     value=$(echo "$item" | jq -r '.login.password')
#                     ;;
#                 totp)
#                     value="$(get_totp "$item_array")"
#                     ;;
#                 url)
#                     value=$(echo "$field_selection" | cut -d' ' -f2-)
#                     ;;
#             esac
#             echo -n "$value" | xclip -selection clipboard -r
#             exit_notification 0 "Success: Copied to clipboard"
#             ;;
#         *)
#             exit "$exit_code"
#             ;;
#     esac
# }
show_entry_fields() {
    # Check for multiple values and handle error
    if [ "$(echo "$1" | jq 'length')" -ne 1 ]; then
        exit_notification 1 "Error: Item $(echo "$1" | jq '.[0].name') is duplicated. Cannot display."
    fi

    item=$(echo "$1" | jq '.[0]')
    fields=()

    # Collect standard fields
    [[ -n "$(echo "$item" | jq -r '.login.username // empty')" ]] && fields+=("username: $(echo "$item" | jq -r '.login.username')")
    [[ -n "$(echo "$item" | jq -r '.login.password // empty')" ]] && fields+=("password: ********")
    [[ -n "$(echo "$item" | jq -r '.login.totp // empty')" ]] && fields+=("totp")
    uris=$(echo "$item" | jq -r '.login.uris[].uri // empty')
    [[ -n "$uris" ]] && while read -r uri; do fields+=("url: $uri"); done <<< "$uris"

    # Collect custom fields
    custom_fields=$(echo "$item" | jq -r '.fields[]? | "\(.name): \(.value // empty)"')
    [[ -n "$custom_fields" ]] && while read -r custom_field; do fields+=("$custom_field"); done <<< "$custom_fields"

    # Display the menu and handle selection
    field_selection=$(printf '%s\n' "${fields[@]}" | rofi_field_menu)
    rofi_exit_code=$?
    if [[ -n "$field_selection" ]]; then
        field_name=$(echo "$field_selection" | cut -d: -f1)
        value=$(echo "$field_selection" | cut -d':' -f2- | sed 's/^ //')

        case "$field_name" in
            password)
                value=$(echo "$item" | jq -r '.login.password') ;;  # Reveal password if selected
            totp)
                value="$(get_totp "$1")" ;;
        esac

        if [[ $rofi_exit_code -eq 10 ]]; then
            echo -n "$value" | xclip -selection clipboard -r
            exit_notification 0 "Success: Copied to clipboard"
        else
            xdotool type --clearmodifiers "$value"
        fi
    else
        exit_notification "$rofi_exit_code" "No selection made."
    fi
}

# Function to display the submenu with appropriate keybindings
rofi_field_menu() {
    msg="| <b>Enter</b>: Type Val | <b>$KB_COPY_FIELD</b>: lock |"
    rofi -dmenu -p 'Field' \
        -i -no-custom \
        -kb-row-up "$KB_ROW_UP" \
        -kb-row-down "$KB_ROW_DOWN" \
        -kb-move-char-back "$KB_MOVE_CHAR_BACK" \
        -kb-move-char-forward "$KB_MOVE_CHAR_FORWARD" \
        -kb-custom-1 "$KB_COPY_FIELD" \
        -mesg "$msg"
}

get_session_key
show_loading "Loading..."
load_cache
unshow_loading
show_items
